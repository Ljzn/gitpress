# 一开始我没想过失败。。。

编程有两种模式： 面向错误处理的编程，和不做错误处理，快速失败的编程。本质上后者只是把错误处理的维度提升到了业务逻辑之外，现在的微服务，沙盒化，云函数等等概念，都可看作是后者的实践。让业务逻辑代码能够专注于实现它所需要实现的功能，而不必去考虑那些未定义的错误情况。

## 聊聊没卵用的区块链

前几天在微博上看到一个不知什么时候发生的采访，有宗庆后，马化腾，杨元庆。宗庆后问马化腾，现在我们的服务器是中国生产的还是美国生产的，马化腾只能😅，后来杨元庆答是联想制造的，大家皆大欢喜。其实大家都知道，联想的产品内部配件来自于世界各地，即使是在中国生产也未必是中国设计。即使全部硬件都来自中国，软件也并非来自中国。

可以讨论一下为什么我们会担心美国制造的服务器。这种担心可以理解，在硬件设备里面嵌入后面，从而窃取信息，这种事情也不是不可能。但从难度和历史来看，在软件中安插后门要容易得多，常见得多。在现在互联网公司的产品开发中，已经极度依赖于开源软件。

目前在开源软件的发布流程，通常采用公布软件包的哈希的方式来保证用户下载到的软件包是没有被恶意修改的。这种方式的问题是，假如有权限公布哈希的Github账号被黑客盗用了，这层保护就没有意义了。

所以还有一些开源软件，例如 node，采用了 GPG 签名的方式，让多个开发者使用自己的私钥对软件包进行签名。黑客必须同时盗用多个开发者的密钥，才能发布恶意的软件包。但难度增大不等于不可能，只要时间足够久，相信黑客还是有机会盗取到全部的开发者的密钥。

区块链被普遍认为是可以从时间维度上一劳永逸解决数据伪造的问题的。通过各种各样的共识机制，以及单向延申的链条，保证了黑客不能够回到链条的中间去修改数据。是不是所有的区块链都能够提供这种保障呢, 要知道现在各种 Proof of X 的机制，真的都可靠吗。

私以为区块链的核心就在于能不能简单地 Verify the Proof，以及伪造 Proof 的难易程度。现在大多数区块链钱包，是自己在云端跑个节点，用户客户端只是用来保存私钥和进行签名。有没有新交易，这些交易是不是真的上链了，客户端都是需要相信服务器。这时候服务器其实是可以在交易的真实性上欺骗客户，尽管不能直接盗取客户的钱，但可以欺骗客户说钱已经发出去，或者钱已经收到了。这在有人使用这个钱包做交易的时候是很危险的。

和 Filecoin 的开发者聊了会儿，发现不管什么链，只要用了 Merkle Tree结构，实现SPV的主要难点都是如何获取到 Merkle Proof。因为这个基本是很难赚钱的服务，需要你保存区块里全部的TXID，除非这个链上的交易量特别大，才会有一部分的用户会需要SPV钱包，才会来使用这种服务，才能赚到一点钱补贴服务器和带宽开销。

![](./images/filecoin.png)

Merkle Tree 的全部意义在于处理巨量的叶子节点，否则还不如一个普通的列表或者普通的树。

所以愉快地达成了共识：交易手续费，狂降！交易量，飙升！否则区块链毫无意义。


## 聊聊我学不会的数学

之前提到过完美数的概念：

> 比如一个数的因子之和（不包括它自己）等于它本身，那么就叫它完美数。比如 6 的因子是 1，2，3，它们的和也是6.

有个好玩的事情是，**全部已知的完美数都是偶数**。乘法和加法被神奇地联系在一起。

## 聊聊我看不懂的lisp

common lisp 真是一门神奇的语言, 对macro特别友好。表达式前面加个`'`， 就变成不执行的AST了。函数名前面加个 `#'` 就变成匿名函数了。这种简洁的语法弊端也很明显，就是太灵活了，不好入门，也很容易写出让别人看不懂的代码。

